@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let index : u32 = GlobalInvocationID.x;
    if(GlobalInvocationID.x >= stats.num_consumers) {
        return;
    }
    let c = consumers[index];
    consumers[index].position += c.step_size;
    let dist = abs(c.position - c.destination);
    let at_destination = all(dist.xy <= vec2<f32>(0.1));
    if (at_destination) {
        consumers[index].step_size = vec4<f32>(0);
	consumers[index].position = c.destination;
        let at_home = all(c.destination == c.home);
        if (at_home) {
            if (c.inventory >= 1) {
                consumers[index].inventory -= 1;
                return;
            }
            consumers[index].color = vec4(1.0, 0.0, 0.0, 0.0);
	    search_for_producer(index);
	    return;
        }

	// At Producer
        let pid = c.producer_id;
        if (pid >= stats.num_producers) {
    	    search_for_producer(index);
	    return;
    	}

	// Picking up inventory
        let inventory = atomicLoad(&producers[pid].inventory);
        if (inventory >= c.demand_rate) {
            consumers[index].color = vec4(0.0, 1.0, 0.0, 0.0);
            consumers[index].destination = c.home;
            consumers[index].step_size = step_sizes(c.position, c.home, c.moving_rate);
            consumers[index].inventory += c.demand_rate;
            atomicSub(&producers[pid].inventory, c.demand_rate);
            stats.transactions += 1;
        }
    }
}

fn search_for_producer(index: u32){
    let c = consumers[index];
    var pid = find_nearest_stocked_producer(c);
    if (pid == 100000) { return; }
    let p_pos = producers[pid].position;	    
    consumers[index].destination = p_pos;
    consumers[index].step_size = step_sizes(c.position, p_pos, c.moving_rate);
    consumers[index].producer_id = pid;
}

// Returns the pid of nearest stocked producer, 100000 for failure
fn find_nearest_stocked_producer(c: Consumer) -> u32 {
    var closest_producer = vec4(10000.0, 10000.0, 0.0, 0.0);
    var shortest_distance = 100000.0;
    var pid: u32 = 100000;
    for(var i : u32 = 0; i < stats.num_producers; i++){
        let dist = distance(c.home, producers[i].position);
        let inventory = atomicLoad(&producers[i].inventory);
        if (dist < shortest_distance && inventory > c.demand_rate) {
            shortest_distance = dist;
	    pid = i;
        }
    }
    return pid;
}
